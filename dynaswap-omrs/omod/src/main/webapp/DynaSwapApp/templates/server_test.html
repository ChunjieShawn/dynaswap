<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Server Test</title>
</head>
<body>
    <h3>Log</h3>
    <p id="log"></p>
    <button id="js-request-data">Ask for public data from server</button>
    <button id="js-calc-secret-key">Calculate secret key using coefficient list</button>
</body>
<script>

    var chatSocket = new WebSocket('ws://127.0.0.1:8000/ws/server_test/');
    var SID = null;
    var z, p, coefficientList;
    const logEl = document.querySelector('#log');

    chatSocket.onopen = function(e) {
        SID = localStorage.getItem("SID")
        // If there is no SID in storage request one
        if(SID === null){
            chatSocket.send(JSON.stringify({
                'action': 'request_SID'
            }))
        } else {
            // show SID for testing purposes
            logEl.innerText += `SID already on machine: ${SID}\n`;
        }
    }

    chatSocket.onmessage = function(e) {
        let data = JSON.parse(e.data);
        if (data['action'] === "receive_public_data"){
            z = data['z'];
            p = data['p'];
            coefficientList = JSON.parse(data['coefficientList']);
            logEl.innerText += `z: ${z}\n`;
            logEl.innerText += `p: ${p}\n`;
            logEl.innerText += `coefficientList: ${coefficientList}\n`;

        } else if (data['action'] === 'receive_SID'){
            localStorage.setItem("SID", data['SID']);
            logEl.innerText += `SID: ${data['SID']}\n`;
        }

    };

    chatSocket.onclose = function(e) {
        console.error('Chat socket closed unexpectedly');
    };

    document.querySelector('#js-request-data').onclick = function(e){
        chatSocket.send(JSON.stringify({
            'action': 'request_public_data'
        }))
    };

    document.querySelector('#js-calc-secret-key').onclick = (e) => {
        if(!hasSIDandPublicData()){
            return alert("Not all data is present. Must have SID and public data");
        }
        const hashedValue = oneWayFunc(SID, z);
        logEl.innerText += `hashedValue: ${hashedValue}\n`;
        let secretKey = calcSecretKey(coefficientList, hashedValue, p);
        logEl.innerText += `secret key: ${secretKey}\n`;
    }

    // Not really the best way to do this but just need a way to ensure all variables are defined
    function hasSIDandPublicData(){
        if(SID === null){
            return false;
        } else if(z === undefined){
            return false;
        } else if(p === undefined){
            return false;
        } else if(coefficientList === undefined){
            return false;
        } else{
            return true;
        }
    }

    function calcSecretKey(coefficientList, x, p){
        let startingExponentNum = coefficientList.length-1
        let sum = 0;
        coefficientList.forEach((coefficient) => {
            coefficientNum = parseInt(coefficient);
            if(startingExponentNum > 0){
                sum += (coefficientNum * Math.pow(x, startingExponentNum));
            } else{
                sum += coefficientNum;
            }
            startingExponentNum -= 1;
        });
        
        // Want to be able to get a positive number when modding a negative
        if(sum < 0){
            return (sum % p) + p;
        } else {
            return sum % p;
        }
    }
    
    // The example one way function as defined Dual Level Key Management paper
    function oneWayFunc(SID, z){
        // XOR on SID and z
        let exponent = SID ^ z;
        return Math.pow(2, exponent); 
    }
    
</script>
</html>